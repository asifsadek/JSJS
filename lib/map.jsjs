val count = /\[T, U](m: <T: U>): num => {
  List.length(keys(m));
};

val values = /\[T, U](m: <T: U>): list U => {
  val aux = /\[T, U](ks: list T): list U => {
    if empty?(ks) then []
    else get(m, hd(ks)) :: aux(tl(ks));
  };
  aux(keys(m));
};

// Returns a map that consists of the rest of the maps conj-ed onto
// the first.  If a key occurs in more than one map, the mapping from
// the latter (left-to-right) will be the mapping in the result.
val merge = /\[T, U](m1: <T: U>, m2: <T: U>): <T: U> => {
  val aux = /\[T, U](m: <T: U>, keys: list T): <T: U> => {
    if empty?(keys) then m
    else {
      val key = hd(keys);
      val value = get(m2, key);
      val newm = set(m, key, value);
      aux(newm, tl(keys));
    };
  };
  aux(m1, keys(m2));
};
