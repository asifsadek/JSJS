// returns the length of a list
val length = /\[T](xs: list T): num => {
  val aux = /\[T](c: num, ys: list T): num => {
    if empty?(ys) then c
    else aux(c + 1, tl(ys));
  };
  aux(0, xs);
};

// returns the nth element of the list
val nth = /\[T](xs: list T, n: num): T => {
  if n == 0 then hd(xs)
  else nth(tl(xs), n-1);
};

// Selects all elements of a list which satisfy a predicate.
val filter = /\[T](pred: (T) -> bool, xs: list T): list T => {
  if empty?(xs) then xs
  else {
    if pred(hd(xs))
    then hd(xs) :: filter(pred, tl(xs))
    else filter(pred, tl(xs));
  };
};

// Selects all elements of a list which do not satisfy a predicate.
val filter_not = /\[T](pred: (T) -> bool, xs: list T): list T => {
  if empty?(xs) then xs
  else {
    if !pred(hd(xs))
    then hd(xs) :: filter_not(pred, tl(xs))
    else filter_not(pred, tl(xs));
  };
};

// prints the elements of a list
val print_list = /\[T](xs: list T): unit => {
  if empty?(xs) then (-) // the unit literal
  else {
    print(hd(xs));
    print_list(tl(xs));
  };
};

// returns a list of numbers from start to end. Like python
// start is inclusive, end is exclusive.
val range = /\(start: num, end: num): list num => {
  if start >= end then []
  else start :: range(start+1, end);
};


// reverses a list
val rev = /\[T](xs: list T): list T => {
  val aux = /\[T](acc: list T, ys: list T): list T => {
    if empty?(ys) then acc
    else aux(hd(ys) :: acc, tl(ys));
  };
  aux([], xs);
};

// concatenates two lists
val concat = /\[T](xs: list T, ys: list T): list T => {
  val aux = /\[T](as: list T, bs: list T): list T => {
    if empty?(as) then bs
    else aux(tl(as), hd(as) :: bs);
  };
  aux(rev(xs), ys);
};

val map = /\[T, U](fn: (T) -> U, xs: list T): list U => {
  if empty?(xs) then xs
  else fn(hd(xs)) :: map(fn, tl(xs));
};

val reduce = /\[T, U](fn: (T, U) -> T, acc: T, xs: list U): T => {
  val aux = /\(acc: T, xs: list U): T => {
    if empty?(xs) then acc
    else aux(fn(acc, hd(xs)), tl(xs));
  };
  aux(acc, xs);
};

val insert = /\[T](xs: list T, x: T, pos: num): list T =>
  // handle error better later, right now just return
  // the original list for invalid position
  if (pos > length(xs) || pos < 0) then xs
  else {
    val aux = /\(count : num, acc : list T, xs : list T): list T =>
        if count == pos
        then concat(rev(acc), x :: xs)
        else aux(count + 1, hd(xs) :: acc, tl(xs));
    aux(0, [], xs);
  };

val remove = /\[T](xs: list T, pos: num): list T =>
  // handle error better later, right now just return
  // the original list for invalid position
  if (pos > length(xs) || pos < 0) then xs
  else {
    val aux = /\(count : num, acc : list T, xs : list T): list T =>
        if count == pos
        then concat(rev(acc), tl(xs))
        else aux(count + 1, hd(xs) :: acc, tl(xs));
    aux(0, [], xs);
  };
